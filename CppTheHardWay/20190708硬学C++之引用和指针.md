# 硬学C++之引用和指针

<u>***知识清单：***</u>

- C++引用(reference) : 变量的**替身**；定义时**必须初始化**；用**&**表示；**不是一个object**（不能被指针指向，不能更换指向）
  - 用处1：作为参数传递到子函数中，不像形参会拷贝到一个新的内存空间。引用是使用相同的变量——效果和指针类似
  - 用处2：作为函数返回值（一般为全局变量或者static）
- 在新标准（C++11）中空指针用`nullptr`表示
- **为防止程序以外崩溃，最好初始化所有的指针**，哪怕是指向`nullptr`
- 为了防止误解，最好将修饰符（`*,&`）和变量放在一起，如`int i1 = 0, *p = &i1, &r = i1`



C++中有一个不同于C语言的设计，就是引入了“**引用（reference）**”的概念。对于我这样一个初学者来说，这个概念并不好理解，而且*引用*在书中和*指针*共同被提出，可见也是容易混淆，这里就简单分析一下这两个概念的区别。今天就先从指针开始。

对学过C语言的人来说，指针应该并不陌生。简单来说，指针就是一个**指向地址**的东西。为什么会有这么一个很别扭的东西出现呢？往下看从汇编语言的角度就可以做出一定的解释。计算机有两大**核心结构**，**计算单元**和**存储器**。一个简易的模型可以是计算单元从存储器中获得要计算的值，进行计算，然后将结果再存回存储器。有了这个**存取**的过程，我们就要知道内存是如何组织的。再一次简化来看，内存就像**一间旅馆**。旅馆有**很多房间**，不同的房间有不同的**门牌号**，只有经过门牌号才能迅速地定位要找的房间在哪。

具体来说，一次计算的过程应该是：程序计数器（Program Counter）从ROM（永久寄存器）中提取出一条指令，比如计算`a+1`，然后计算机解析之后，就发送变量`a`的地址给存储器，存储器相应的就会把`a`的值放到门口等待计算单元取走，计算单元在确定存储器准备好了之后就会取走这个二进制数，把它存入内部的寄存器（暂放等待处理的地方）。然后在另一个寄存器中生成数字`1`。执行加法。完成之后将结果放回另一个寄存器，然后通知内存，执行一个反向操作将值传回内存。

对于完全不懂计算机的人来说，还有一个概念需要解释一下，就是**传**和**取**这两个词都十分具有类比特质，在计算机中到底意味着什么。简单来说就是通过三极管或者场效应管的开合来进行电信号的传递……好吧这样解释更复杂了……我就此打住！

所以所以所以，有了指针的概念，因为**计算机需要知道从哪个地址取值**。这么说虽然有道理，但是作为编写程序的人，我们为什么需要使用指针？我们定义了变量（或函数），对于这些名称，计算机自然能找到他们的地址，我们执行操作就行了，还用知道地址干嘛？市面上其他的高级语言无一例外地都取消了指针的概念，C和C++因和要如此操作？

我的心中已经有了两个不成熟的想法，一个是从**实用主义**的角度出发；另一个是从C语言本身的**设计“缺陷”**出发。

从实用主义的角度来说，计算机交给程序员钥匙，更加能够方便程序员对存储单元的直接处理，进行组织上的优化，使得程序设计更加简单透明。这么说是有前提的，C语言**面向机器**，更贴近**汇编**的逻辑，而且早年的计算机能力有限，内存一共也没有多少，所以作为古董级别的计算机语言，具有这种功能是可以理解的。随着计算机的发展，内存大到十几个GB成功比以前多出了**近百万倍**，人为的处理已经远远逊于计算机按照一定的规则自动的处理，指针的存在有时反而成为了问题，造成了很多程序编写上的不便和错误。

从C语言本身的设计而言，在进行函数操作的时候，计算机会对函数中传递的参量进行**一份拷贝**，在另外的内存空间中进行运算然后将这些拷贝“销毁”，只传递结果回去。一个经典的案例就是`swap(a,b)`，我要交换a和b的值，交换完了回到原来的地方啥也没变因为是拷贝自己兑换了，原来的值压根没变。这就让人想到了指针……

这个问题恰恰也引出了开头说到的另一个概念“引用”，我们明天再接着说。

***总结一下：***

看待一个问题，我们可以从**设计者**的角度出发，也可以从**使用者的实用主义**的角度出发；我们还应该具有用**发展**的眼光看问题的能力，不局限于一时一刻的因果，而是从更长远的视角来考虑这件事情的流变。