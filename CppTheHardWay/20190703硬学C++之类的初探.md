# 硬学C++之"类"的初探

<u>***知识清单：***</u>

- 使用 `while (std::cin >> value)` 处理不定量输入时，`while`的判断条件是 `>>` 运算符的返回值。如果输入运算符的两侧数据类型相同，则返回非0，否则返回0，中断输入循环。
- 在类中除了可以定义变量和方法，还可以**重新改写（重载）运算符**，比如 `<< >> + - `等。 



昨天犯了**审题不清**的错误，实在是把问题考虑复杂，按照昨天我的理解，怎么说也得涉及初步的数据结构了，但是一个C++入门的程序怎么可能需要考虑这么多问题呢？果然是我理解错了问题。原来的问题仅仅是读取连续读取数据（形式如 `ISBN 4 25.5`）,如果连续两个ISBN相同，则加和数量并重新计算平均价，如果ISBN不同，则输出之前的结果并着手计算另一本书的数据。这就意味着问题有一个**隐含的假设**，所有的数据已经按照ISBN号排序，只是存在有些书以不同的价格在不同的时候售卖，在这里只需要统一计算总量和平均价，**并不涉及数据的存储和查找**。所以这个问题实际就转变成了**对*类*的使用**以及对基本**流控制**（条件和循环）语句的练习。

另一个让我没想到的是，第一章对“类”的解释仅仅停留在*类*的使用，而并没有深入到*类*的编写，可能也是为了照顾读者的水平，降低入手的门槛。既然作者给出了调用*类*的`main`函数，不如我明天就逆向就此写一个相对应的类出来试试。

不过C++有一个特点让我感到惊讶，**类和类之间是可以进行运算的**，这也就意味着在*类*中可以改写每种运算符的定义。打个比方，我们可以定义一个家庭里面的两个人 `A+B=两人的工资总和`，`A*B=两个人做家务能节省的时间比例`，`A&&B=两个人一起吃饭的次数` 等等。**两个抽象的人（类），其中可以具体到很多的特征，对于这些特征所做的运算是可以用普通的运算符重新定义的**。这也应证了书里所说的一句话：*类*的设计是尽量**让其可以像内建变量类型一样进行处理和运算**。这是一种高级的设计形态和思维模式。

可是，`java`中就没有支持重载运算符，从一个更宏大的视角来看，如果一个项目有好几百个类，每个类都自己定义了一个加法 `+` 运算，在实际操作中，很快就会混淆了每一个类的 `+` 运算意味着什么。作为特例，或许这样可以大量的简化代码，但是如果变成了普遍的选择，加法 `+` 运算的**一般性**就失去了。失去一般性的设计会产生大量的记忆需要，也会造成很多的不便和返工。这也是我们在自己做出设计的时候需要考虑的问题，既然C++给出了这样的方便法门，在使用时就格外需要注意，像我上文叙述的那些重载运算符的方式就非常不好，只有在符合大多数人直觉的情况下进行重载，才能达到使用的效果。

同样的视角也可以运用在产品设计上。我们需要给用户留出多少的自定义空间？Linux和Windows就是两个极端，一个是完全可以自定义，另一个是封闭系统，我们搞不懂也无需搞懂操作系统组织的细节。Linux意味着很高的学习成本，但是一旦掌握，在使用效率上可以远超windows，但却是windows真的让电脑走进了千家万户。

其实很多时候我们都面临着这样的取舍，我们需要的究竟是**选择**还是**控制感**？这让想起了一个著名的谈判技巧，**如果你想让自己的意见被采纳，就给出两个选项，另一个是对方绝对不会选的**。往往在这种情况下，做出选择的快感得到满足，但是其实钻进了设计好的剧本。另一个谈判技巧是**讨论方式而不是结果**，比如想让孩子去写作业的时候不是问“你要不要去写作业？”，而是问“**你是要我在你写作业的时候看书还是看剧？**”

反过来思考这个问题也是一样，当我们面临一个选择的时候，尤其是二元选择的时候，要多思考一步，**我有其他的选项吗**？只有不断的跳出当下角度来思考这个问题，才能不被设计好的选择左右。

*<u>总结一下：</u>*

今天讨论了一个关于“选择”与“控制感”的问题，作为设计者，为了避免“复杂性灾难”，应该减少选择，而同时又需要尽量保证用户的“控制感”。而作为受众，我们应该时刻警惕被别人设计好的选择题，或误把多选题做成单选题。

**所以，你是打算给我打赏呢还是分享到“在看”呢？**