# 硬学C++之const浅析

<u>***知识清单：***</u>

- `const`的本意就是**不能被随意更改**，用`const`定义变量视同常量
- `const`常量定义必须被初始化，可以是运行时（Runtime）初始化，也可以是编译时初始化。
- 我们可以像使用`const`所定义的类型那样使用这种常量，**唯独不能试图改变它的值**
- 在未用`extern`指明的情况下，`const`常量是局部的
- **对`const`常量的引用**（Reference to `const`）：`const int v1 = 10; const int &r1 = v1`
- 只有**对`const`常量的引用**才能引用`const`常量——非对`const`常量的引用不行
- **对`const`常量的引用**可以引用普通变量，数值常量，或由此构成的表达式（**引用特例之一**）
- 建立引用时要保持引用本身的类型匹配（反例：`double dval = 3.14; const int &ri = dval`）
- **对`const`常量的引用**的对象未必是`const`，原因是我们不希望通过这个引用来改变这个变量，但是我们可以通过别的方式改变
- **指向`const`常量的指针**自身也必须是`const`——不能试图改变常量
- 我们可以使用**指向`const`常量的指针**来指向非`const`变量（**指针特例之一**）（这类指针或引用认为自己指向的是常量，所以任何试图通过它们来改变常量的值的行为都是非法的，但是他们本身指向的是不是常量是另一回事）
- 由于指针本身是一种对象（不像引用），所以存在**`const`的指针**（以下我称为**指针常量**），如同所有`const`类型的常量，**指针常量**也必须要被初始化 （`int *const cp` 区别于 `const int *p`）
- `int *const cp`的理解应当从右往左，这是一个叫做**`cp`**的**常量**，这个**常量**是一个`int*`(**指向整形的指针**)类型的常量
- **指针常量**并不规定我们是否能够通过此指针改变这个常量，而只是说明指针本身所指向的地址是不可改变（死指针）
- **指针常量**中的`const`被称为Top level `const`, **指向`const`常量的指针**中的`const`被称为Low level `const`
- 在拷贝时，Top level `const`可以被忽略
- 常量表达式（constant expression）是在编译时就可以确定的常量，区别于Runtime的`const`
- `constexpr`向编译器指明这是编译时就需要确定的常量。`constexpr int *p`中`constexpr`是Top level `const`，只表明此指针是常量



`const`是看到目前觉得比较绕的一个概念，所以我仔细的列出了书中写的几乎每一条注意事项，以备日后查验。其实如果要抓住本质，`const`就是**常量**的意思，**常量**意味着程序运行中**不可被更改**。在这其中又有两点要注意的地方：首先，常量和**宏定义**不同的是，常量仍有类型，可参与的运算种类会更多，而宏定义是**直接替换**，并不包括类型的定义；其次，常量未必需要在编译时就定义，也**可以在运行时定义**，但是不能被更改。

抓住常量的本质——**不可被更改**，之后理解起来就会容易许多。首先要根据一定的规则明确常量所指的类型，尤其是**指针常量**和**指向常量的指针**乃至**指向常量的指针常量**之间的分辨。确定对象之后，就要看程序是不是有要通过各种方式试图篡改这个值。

假设我们定义一个**指针常量**`int a; int *const p = &a`，接下来如果我们做这样的操作`*p = a + 5`，我们试图改变这个指针所指向的内容（a）的值，这并不违反规则，指针本身没有改变指向。但如果我们试图做以下操作就违反了规则：`int *p2 = &b; p = p2` 

同理我们可以定义一个**指向常量的指针**，这个指针的特点就是**不允许程序试图通过它来改变所指对象的值**。设想一个情景，游戏中的装备玩家可以使用，但是不能随意对此更改，可是对于管理员来说这又是可以更改的。在程序设计时可能的体现就是玩家调用这个装备时使用的就是指向常量的指针，但是管理员调用时就是普通指针。

今天主要钻研了`const`修饰符的概念，程序语言中的设计都是十分有逻辑的，只要抓住一个问题的本质就可以触类旁通。但是生活中很多其他的方面并不是这样，往往需要具体问题具体分析，切不可跳入固定思维的陷阱。