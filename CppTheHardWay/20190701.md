把一天的刻度换到6点除了这是得到的更新时间以外还因为这差不多是下班的时间。在下班之前提前做好接下来的计划安排，在回家之后不会觉得是一天的结束，而是一天的开始。

通勤的时间加上做饭和吃饭的时间不算，大概最迟从7:30开始就可以进入新的一天的学习，这个时段大概可以腾出**2小时**。这两个小时的主要任务是学习每天制定的计划，近期来看就是C++。把文稿开在旁边，随时记录。

然后就是睡前的时间，主要用来看书或者得到的笔记和留言。

起床之后到上班之前的时间整理发布每天的文章。这样督促自己能够高效发文，而不会拖沓。为方便配图直接取当日的物种日历图。早上预留**1小时**。



# 硬学C++之基础中的基础

我的工作主要涉及的是嵌入式系统。嵌入式系统的特点就是“**小**”，在计算机语境下的“小”就意味着**资源有限**。所以我认为嵌入式这门学问容易把人培养成为**保守主义者**，每每一个新技术出现，比如人工智能，深度学习，区块链，嵌入式工程师问的第一个问题就是：**板子上能跑得动吗？**

这个问题其实覆盖了至少两个层面：**第一，资源够不够用？**就好比一口小锅能不能炒的下一群人要吃的菜。第二，**速度够不够快？**锅小说不定我可以分成几波来炒，可是如果我炒得太慢了，客人们可能就等不及了。那如果我一个人炒得慢，我就多雇几个人炒，可是这个时候有要考虑我有几个灶的问题了，这就又回到了资源。这两个问题一个是能不能的问题，另一个是好不好的问题，两个问题同时决定了这件事情能不能实现的**底线**。当然延伸开去还有**能耗**和**成本**的问题，这些问题追本溯源也可以回到资源和效率上。

不过嵌入式工程师们也不能渴求人工智能工程师，谈论一个科技的发展我们需要讨论一个平台。对于人工智能而言，其应用场景在于**大**数据——无论是学习的过程还是决策的过程，都需要大量的数据和计算来支撑。可以说是**量**和**速**催生了现在的这些科技。

但即使是这样，人工智能的算法也是需要优化的。随着智能化的设备逐渐下行到很多功能化产品中，这些原本小型、轻量、低配的产品也必须配备一定限度的数据存储、处理和传输能力。而这种优化的实现，很大程度上取决于编程语言的使用。

在操作系统层级的语境中，C语言和C++仍然处于统治地位，原因就在于它们更知道如何**与机器沟通**。计算机的所有复杂操作其实都是简单动作的组合，最基本的动作包括**移动数据**、**加减乘除**的运算，以及**逻辑判断**。这些分别能够对应到数字电路的知识点中，可见是基本中的基本。为了完成相应的动作，会设计一套**机器语言指令集**，接下来的一切复杂操作就是基于有限的机器语言之上。因为机器语言是一串二进制数，为了方便人的记忆，将这些二进制数与其功能相对应产生了**汇编语言**。

自此，编程需要的都是**机器思维**。所谓机器思维，就是所有的动作都要在有限的指令之中去思考完成，比如在UART串口上打印“Hello World”。思考的逻辑大概是，首先要配置串口这个外设相关的寄存器，将他设置为输出的模式，然后将Hello World的字母H放入发送寄存器中，然后去查看发送控制寄存器的相关位，确定发送是否完毕，再将下一个字母放入，直到发送完毕。

看起来十分复杂，可是这种诸如发送内容到串口的行动我们应该经常使用才对，而且无论发送的是什么，操作都非常类似，所以为何不把它单独作为一个函数封装起来，取名叫做print，以后每次用到我就传递我想要打印的字符串给这个函数，然后它自己就能完成这个任务。如此，一个个功能被封装起来，编程的逻辑从机器思维逐渐转化为人的思维，由此催生了种种**高级语言**，C语言就是其中之一。

Linux操作系统的内核就是用C语言写的，可见C语言是操作系统级别的语言，意味着在编译的效率上是非常有优势的。编译的过程可以理解为翻译，就是将人说的话翻译成机器听得懂的语言。但是如果人的语言不遵循一定的规则，这种翻译有时是非常困难的，比如“把杯子给我拿来”这句话就缺少了很多信息：哪一个杯子？杯子在什么地方？你又在什么地方？到了距离你多远的的地方算达成目标？要不要在拿来之前直接给你灌上水？……诸如此类一个眼神就可以确认的问题，计算机都很难处理，这也就是为什么**NLP自然语言处理**在现今发展迅速的原因。可以想见在未来会有新的编程语言，口述就可以完成，而接受这种语言的终端就会无限接近“人工智能”。回到现实中来，C语言之所以相对抽象，是为了兼顾机器语言的逻辑，我们所写的代码首先要能够让编译器能够看懂，为此必须要符合许多的**语法规范**。

说了这么多，我为什么要学C++呢？程序设计要兼顾一个平衡，**程序设计难度**和**机器运行效率**。由于机器和人思维的底层逻辑不同，所以越是设计起来简单的程序，其背后需要考虑的问题就越是多这也就意味着机器运行的效率要大打折扣，做很多不必要的事情。而如果一个项目变得十分复杂，让人按照机器逻辑去思考和界定很多问题也显得捉衿见肘。在此之间需要找一个平衡点，而这个平衡点的选取就与**项目的复杂程度**和对**机器的依赖程度**有关。

|          | 不依赖机器                 | 依赖机器      |
| -------- | -------------------------- | ------------- |
| 项目简单 | python等贴近自然逻辑的语言 | C语言，汇编等 |
| 项目复杂 | Java, C#                   | C++           |

这种分类有失偏颇，尤其是关于python的分类，但只是为了表现一个大概的思路：鉴于我的工作场景是**嵌入式系统**，所以无论如何也要考虑**硬件的能力**，在项目逐渐复杂的过程中，C++是一个我没办法避开的语言。以至于C++有什么特点，面向对象编程又意为着什么，就在我接下来不断学习的过程中再分享了。

***<u>总结一下：</u>***

实际生活中，我们需要考虑到资源和需求的匹配，所谓没有金刚钻就别揽瓷器活。其次，资源底线不是我们停滞不前的借口，要通过不断的学习和优化来利用已有的资源更好的完成任务。最后，做出选择的过程也是作出牺牲的过程，要首先确立一个选择标准，然后再进行取舍。



