# 硬学C++之类型的迷思

***知识清单：***

- 除了`typedef`之外，C++11还引入了`using SI = Sales_item`这种给类型起小名的方法
- `typedef char *pstring ; const pstring cstr = 0 ; const pstring *ps ;` 在上述语句中，首先我们定义了`pstring`类型为**指向char的指针**，那么在第二句中，`cstr`则是**指向char的const指针**，这里需要做一下语义分析，`const`**作用于主语**，在上一个定义中，主语是**指针**，所以它是**常量指针**，而这个指针指向的是`char`这个特征保留。在第三句中，定义了一个**普通指针**，这个指针指向`const`的`pstring`。什么是**`const`的`pstring**`，参见刚刚的解释。
- **注意！**不能把`typedef`的内容直接代入，代入之后符号优先级会发生变化，导致解释不同。`const char *cstr`是一个**普通指针**，指向`const`的`char`。
- `auto`类型：在我也不知道它到底是什么类型（`int double float...`）的时候用。所以其定义时必须初始化。初始化之后虽然我们不确定类型，但是计算机已经推测出了它的类型，并且按照它的类型进行空间的分配。在这时如果使用一个不匹配的指针类型去读取，则会造成错误。
- 在使用`auto`时，Top level的`const`被无视，也就是说如果我是一个常量指针，那么对于`auto`我就是普通指针，但如果我是指向常量的普通指针，auto之后我还是指向常量（后者时low-levl）。如果我们要保留或增加top level 的`const`，就必须使用`const auto`明确声明。
- **注意！**用`auto`定义一组内容的时候，这一组内容内部要统一，否则`auto`在被替换之后可能会产生类型错误，如`auto &n = int_type_var, *p2 = &const_int_type`这里`auto`如被解释成**整形**，那么`p2`就是指向整形的指针，然而此处需要的是指向**常量整形**的指针（如果另起一行）。所以发生错配。
- 习题：

```c++
const int i = 42;
auto j = i; const auto &k = i; auto *p = &i;
const auto j2 = i, &k2 = i;
```

- 解答：`const int i = 42` 定义了一个**整形常量**`i`。`auto`定义的`j`无视常量符，所以时一个**整形变量**。`k`是`i`的一个reference，而且是一个**整形常量**的引用（因为被指明），引用对象是`i`。最后`p`是一个**普通指针**，指向**整形常量**。第二行中，首先定义了`j2`是一个整形常量（42），然后定义了`k2`作为另一个对`i`的引用。



能看懂我之前写的清单的，**我真的服了**！要么就是我解释的逻辑太清楚了。反正我自己是快糊涂了……

